---
title: "How It Works"
description: "The architecture behind verifiable geospatial computation"
---

<Warning>
  **Development Preview** — Architecture is under active development.
</Warning>

# How Astral Location Services Works

Astral provides verifiable geospatial computation by combining three key technologies: **PostGIS** for spatial operations, **EigenCompute TEE** for verifiable execution, and **EAS** for attestation management.

## System Architecture

```mermaid
flowchart TB
    subgraph App["Developer Application"]
        A1[Collects user location]
        A2[Calls Astral SDK]
    end

    subgraph SDK["Astral SDK (@decentralized-geo/astral-compute)"]
        S1["astral.location.* (create, get, query)"]
        S2["astral.compute.* (distance, contains, etc.)"]
        S3[Request signing, attestation decoding]
    end

    subgraph Gateway["Astral API Gateway (api.astral.global)"]
        G1["/locations/* → Indexer"]
        G2["/compute/* → Policy Engine"]
    end

    subgraph Services["Backend Services"]
        subgraph Indexer["Indexer Service"]
            I1[Syncs EAS]
            I2[OGC Features]
        end

        subgraph Compute["Geospatial Policy Engine (TEE)"]
            C1[TypeScript API Layer]
            C2[PostgreSQL + PostGIS]
        end
    end

    App --> SDK
    SDK --> Gateway
    Gateway --> Services
```

## Key Architectural Decisions

<AccordionGroup>
  <Accordion title="Self-Contained Container" icon="box">
    PostGIS runs **inside** the Docker container, not as an external service. This is essential for verifiable computation in the TEE — no external dependencies means the entire execution environment is attested.
  </Accordion>
  <Accordion title="Stateless Model" icon="rotate">
    Each request brings all required inputs. No persistent state between requests. This ensures determinism and simplifies verification — same inputs always produce same outputs.
  </Accordion>
  <Accordion title="Separate Service" icon="layer-group">
    The compute service is deployed independently from the indexer. They share nothing at runtime. This separation enables the compute service to run in a TEE without compromising the indexer's functionality.
  </Accordion>
  <Accordion title="Delegated Attestations" icon="signature">
    Developers submit Policy Attestations onchain using EAS's delegated attestation pattern. Astral signs, developer pays gas, Astral is recorded as the attester.
  </Accordion>
</AccordionGroup>

## The Computation Flow

<Steps>
  <Step title="Request Arrives">
    Developer's app calls `astral.compute.within(uid1, uid2, 500)` via the SDK
  </Step>
  <Step title="Input Resolution">
    The compute service fetches/validates location attestations by UID, or accepts raw GeoJSON
  </Step>
  <Step title="Spatial Computation">
    PostGIS executes the spatial operation (e.g., `ST_DWithin`) inside the TEE
  </Step>
  <Step title="Result Signing">
    The service creates a Policy Attestation and signs it with the TEE-held key
  </Step>
  <Step title="Response">
    Signed attestation returned to SDK, ready for offchain use or onchain submission
  </Step>
</Steps>

## Verifiable Execution with EigenCompute

The geospatial policy engine runs in **EigenCompute**, part of the EigenCloud ecosystem:

```mermaid
flowchart TB
    subgraph TEE["EigenCompute TEE Environment"]
        subgraph Container["Docker Container"]
            subgraph Engine["Astral Geospatial Policy Engine"]
                E1["TypeScript/Node.js API"]
                E2["Request validation"]
                E3["Signature verification"]
                E4["PostGIS query execution"]
                E5["Policy Attestation signing"]
            end
            subgraph DB["PostgreSQL + PostGIS"]
                D1["Spatial computations (GEOS)"]
                D2["Ephemeral - no persistent state"]
            end
            Engine --> DB
        end
    end
```

<Info>
  PostGIS uses [GEOS](https://libgeos.org/) under the hood for geometry operations. GEOS is the gold standard C++ geometry library used by most geospatial software.
</Info>

### Verifiability Properties

| Property | How It's Achieved |
|----------|-------------------|
| **Input Verification** | Attestation signatures verified at TEE boundary |
| **Deterministic Computation** | Same inputs always produce same result |
| **Signed Output** | Service key signs Policy Attestation inside TEE |
| **TEE Attestation** | EigenCompute provides hardware attestation of execution |

## Input Resolution

The service accepts multiple input formats:

| Input Format | Resolution |
|--------------|------------|
| UID string | Fetch from EAS contracts (onchain attestations) |
| `{ uid, uri }` | Fetch from URI, verify UID matches, verify signature |
| `{ attestation }` | Verify signature, extract geometry directly |
| Raw GeoJSON | Use directly, hash for `inputRefs` |

<Note>
  For offchain attestations, the UID is deterministically derived from the attestation data. Even when fetching from HTTPS (not content-addressed), we verify the fetched attestation produces the expected UID. Mismatch = reject.
</Note>

## Delegated Attestation Flow

```mermaid
sequenceDiagram
    participant Dev as Developer App
    participant SDK as Astral SDK
    participant Svc as Compute Service
    participant EAS as EAS Contracts
    participant Res as Resolver

    Dev->>SDK: compute.within(...)
    SDK->>Svc: POST /compute/within
    Svc->>Svc: Execute PostGIS operation
    Svc->>Svc: Sign attestation
    Svc-->>SDK: Signed attestation + delegated sig
    SDK->>EAS: Submit with Astral's signature
    EAS->>Res: onAttest() callback
    Res->>Res: Execute business logic
```

The delegated attestation pattern means:
- **Astral signs** the attestation data offchain
- **Developer submits** with Astral's signature (pays gas)
- **EAS verifies** the signature and records Astral as attester
- **Resolver contracts** can verify `attestation.attester == astralSigner`

## Trust Model

### Current (MVP)

The trust assumption is **not** that Astral operates honestly — it's that the TEE operates correctly:

- **Open source code**: The compute service code is public and auditable
- **TEE execution**: Code runs inside EigenCompute's trusted execution environment
- **Remote attestation**: EigenCompute provides hardware attestation that the expected code is running
- **Deterministic operations**: Same inputs always produce same outputs, enabling verification
- **Astral signing key**: Signs attestations inside the TEE

You don't need to trust Astral — you need to trust the TEE boundary and that the published code matches what's running.

### Future

- **AVS Consensus**: Multiple operators verify computations
- **ZK Proofs**: Cryptographic proof of correct execution
- **Decentralized Signers**: Multi-party attestation signing

<Card title="Next: Core Concepts" icon="book" href="/concepts/location-attestations">
  Deep dive into Location Attestations
</Card>

---
title: "Quickstart"
description: "Build a location-gated NFT"
---

<Warning>
  **Development Preview** — Code snippets demonstrate the intended API and need testing against the actual implementation.
</Warning>

# Build a Location-Gated NFT

Create an NFT that can only be minted when a geospatial policy check passes — "is the user within 500m of the Eiffel Tower?"

<Info>
  **About location verification**: This guide uses location data as input, but doesn't verify *where* that data came from. GPS is spoofable. We're developing [Location Proof plugins](https://collective.flashbots.net/t/towards-stronger-location-proofs/5323) to address this — they'll integrate with the flow shown here.
</Info>

## What You'll Learn

<Steps>
  <Step title="Register a reference location">
    Create a location attestation for the Eiffel Tower
  </Step>
  <Step title="Check the geospatial policy">
    Use Astral to verify proximity
  </Step>
  <Step title="Gate the smart contract">
    Use EAS resolvers to mint based on the policy result
  </Step>
</Steps>

## Prerequisites

```bash
npm install @decentralized-geo/astral-compute ethers
```

You'll need:
- A wallet with testnet ETH (Base Sepolia)
- Basic TypeScript and Solidity knowledge

---

## Step 1: Register the Eiffel Tower

First, create a location attestation for the Eiffel Tower that can be referenced by UID.

<Note>
  **Code snippets need testing** — Verify against actual implementation before use.
</Note>

```typescript
import { AstralClient } from '@decentralized-geo/astral-compute';
import { ethers } from 'ethers';

// Connect your wallet
const provider = new ethers.JsonRpcProvider('https://sepolia.base.org');
const wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider);

// Initialize Astral client
const astral = new AstralClient({
  signer: wallet,
  chainId: 84532  // Base Sepolia
});

// Define the Eiffel Tower as a point
const eiffelTowerLocation = {
  type: 'Point',
  coordinates: [2.2945, 48.8584]  // [longitude, latitude]
};

// Create a location attestation
const eiffelTower = await astral.location.create(eiffelTowerLocation, {
  chainId: 84532,
  submitOnchain: true,
  metadata: {
    name: "Eiffel Tower",
    description: "Iconic Paris landmark"
  }
});

console.log('Eiffel Tower UID:', eiffelTower.uid);
// Save this UID - it's a reference to this location
```

<Note>
  Location attestations follow the [Location Protocol v0.2](https://github.com/DecentralizedGeo/location-protocol-spec/tree/v0.2-draft) schema.
  Anyone can now reference the Eiffel Tower by UID instead of hardcoding coordinates.
</Note>

---

## Step 2: Check the Geospatial Policy

When the user is ready to claim, submit their location to Astral for policy evaluation.

<Warning>
  **Location source matters**: The `userCoords` below comes from GPS, which is spoofable. In production, integrate [Location Proof plugins](https://collective.flashbots.net/t/towards-stronger-location-proofs/5323) to provide evidence-based location claims.
</Warning>

<Note>
  **Code snippets need testing** — Verify against actual implementation before use.
</Note>

```typescript
// User's location (from GPS or location proof plugin)
const userCoords = {
  type: 'Point',
  coordinates: [2.2951, 48.8580]
};

// Create user's location attestation
const userLocation = await astral.location.create(userCoords, {
  chainId: 84532,
  submitOnchain: true
});

// Check proximity policy using delegated attestation pattern
const result = await astral.compute.within({
  geometry: userLocation.uid,
  target: eiffelTower.uid,
  radius: 500,  // meters
  chainId: 84532,
  schema: RESOLVER_SCHEMA_UID,
  recipient: wallet.address
});

// Behind the scenes:
// 1. Astral computes ST_DWithin in PostGIS (inside TEE)
// 2. Signs a policy attestation with the result
// 3. Returns delegated attestation for you to submit

console.log('Result:', result.result);  // true or false

// Submit onchain if policy passed
if (result.result) {
  const tx = await astral.eas.submitDelegated(result.delegatedAttestation);
  await tx.wait();
  console.log('Attestation submitted:', tx.hash);
}
```

<Info>
  The service runs inside EigenCompute's TEE, providing verifiable execution. The signed attestation proves the computation was performed correctly.
</Info>

<Tip>
  **For UX feedback**: Use [Turf.js](https://turfjs.org/) for instant client-side distance calculations before submitting to Astral for verified computation.
</Tip>

---

## Step 3: The Smart Contract (EAS Resolver)

Your resolver contract gates NFT minting based on the policy attestation.

<Note>
  **Code snippets need testing** — Verify against actual implementation before use.
</Note>

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@eas/contracts/resolver/SchemaResolver.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

contract EiffelTowerNFT is SchemaResolver, ERC721 {
    address public astralSigner;
    uint256 public nextTokenId = 1;
    mapping(address => bool) public hasMinted;

    constructor(IEAS eas, address _astralSigner)
        SchemaResolver(eas)
        ERC721("Eiffel Tower Visitor", "EIFFEL")
    {
        astralSigner = _astralSigner;
    }

    function onAttest(
        Attestation calldata attestation,
        uint256 /*value*/
    ) internal override returns (bool) {
        // 1. Verify attestation is from Astral
        require(attestation.attester == astralSigner, "Not from Astral");

        // 2. Decode the policy result
        (
            bool policyPassed,
            bytes32[] memory inputRefs,
            uint64 timestamp,
            string memory operation
        ) = abi.decode(
            attestation.data,
            (bool, bytes32[], uint64, string)
        );

        // 3. Verify policy passed
        require(policyPassed, "Not close enough");

        // 4. One mint per address
        require(!hasMinted[attestation.recipient], "Already minted");

        // 5. Mint NFT atomically
        hasMinted[attestation.recipient] = true;
        _mint(attestation.recipient, nextTokenId++);

        return true;
    }

    function onRevoke(Attestation calldata, uint256)
        internal pure override returns (bool)
    {
        return false;
    }
}
```

---

## Prerequisite: Deploy Resolver and Register Schema

<Warning>
  You must complete this step **before** running Step 2. The `RESOLVER_SCHEMA_UID` is required for the policy check to trigger your resolver.
</Warning>

<Note>
  **Code snippets need testing** — Verify against actual implementation before use.
</Note>

```typescript
// Deploy resolver
const EiffelNFT = await ethers.getContractFactory("EiffelTowerNFT");
const resolver = await EiffelNFT.deploy(
  EAS_ADDRESS,
  ASTRAL_SIGNER_ADDRESS  // See security notes for signer management
);
await resolver.waitForDeployment();

// Register schema with EAS
const schemaRegistry = new SchemaRegistry(SCHEMA_REGISTRY_ADDRESS);
const schema = "bool result,bytes32[] inputRefs,uint64 timestamp,string operation";

const tx = await schemaRegistry.register({
  schema,
  resolverAddress: resolver.address,
  revocable: false
});
const receipt = await tx.wait();

const RESOLVER_SCHEMA_UID = receipt.logs[0].args.uid;
console.log('Schema UID:', RESOLVER_SCHEMA_UID);
// Use this UID in Step 2 when calling astral.compute.within()
```

---

## The Complete Flow

<Note>
  **Code snippets need testing** — Verify against actual implementation before use.
</Note>

```typescript
import { AstralClient } from '@decentralized-geo/astral-compute';

const astral = new AstralClient({ signer: wallet, chainId: 84532 });

// 0. Deploy resolver and register schema (see Prerequisite section)
const RESOLVER_SCHEMA_UID = '0x...';  // From schema registration

// 1. Reference location exists
const landmarkUID = '0x...';  // Eiffel Tower

// 2. User arrives — create location attestation
const userLocation = await astral.location.create(userCoords, {
  chainId: 84532,
  submitOnchain: true
});

// 3. Check policy + submit attestation
const result = await astral.compute.within({
  geometry: userLocation.uid,
  target: landmarkUID,
  radius: 500,
  chainId: 84532,
  schema: RESOLVER_SCHEMA_UID,
  recipient: userAddress
});

if (result.result) {
  const tx = await astral.eas.submitDelegated(result.delegatedAttestation);
  await tx.wait();
  console.log('NFT minted!');
}
```

---

## Next Steps

<CardGroup cols={2}>
  <Card title="Core Concepts" icon="book" href="/concepts/location-attestations">
    Understand the building blocks
  </Card>
  <Card title="Use Cases" icon="lightbulb" href="/use-cases">
    Explore what you can build
  </Card>
  <Card title="API Reference" icon="code" href="/api-reference/overview">
    Dive into the API details
  </Card>
  <Card title="SDK Reference" icon="cube" href="/sdk/overview">
    Full SDK documentation
  </Card>
</CardGroup>

---
title: "Compute"
description: "Geospatial computation methods"
---

<Warning>
  **Development Preview** â€” The SDK is under development.
</Warning>

# Compute Methods

The `AstralCompute` class provides verifiable geospatial operations.

```typescript
import { AstralCompute } from '@decentralized-geo/astral-compute';

const compute = new AstralCompute({ chainId: 84532 });
```

## Input Types

All methods accept flexible input types:

```typescript
type Input =
  | string                              // Onchain attestation UID
  | GeoJSON.Geometry                    // Raw GeoJSON
  | GeoJSON.Feature                     // GeoJSON Feature
  | { attestation: OffchainAttestation } // Inline offchain attestation
  | { uid: string, uri: string }        // Offchain by reference
```

## Compute Options

All methods accept options:

```typescript
interface ComputeOptions {
  schema: string;         // Required: EAS schema UID
  recipient?: string;     // Optional: attestation recipient (defaults to zero address)
}
```

---

## distance()

Calculate distance between two geometries.

```typescript
compute.distance(
  input1: Input,
  input2: Input,
  options: ComputeOptions
): Promise<NumericComputeResult>
```

### Example

```typescript
const result = await compute.distance(
  userLocationUID,
  landmarkUID,
  { schema: SCHEMA_UID }
);

console.log(result.result);  // 523.45 (meters)
console.log(result.units);   // "meters"
```

---

## contains()

Check if a geometry is inside a container.

```typescript
compute.contains(
  container: Input,
  geometry: Input,
  options: ComputeOptions
): Promise<BooleanComputeResult>
```

### Example

```typescript
const result = await compute.contains(
  sfBayAreaUID,       // Polygon
  userLocationUID,    // Point
  { schema: SCHEMA_UID }
);

console.log(result.result);  // true or false
```

---

## within()

Check if a geometry is within a radius of a target.

```typescript
compute.within(
  geometry: Input,
  target: Input,
  radius: number,        // meters
  options: ComputeOptions
): Promise<BooleanComputeResult>
```

### Example

```typescript
import { AstralCompute, AstralEAS } from '@decentralized-geo/astral-compute';

const compute = new AstralCompute({ chainId: 84532 });
const eas = new AstralEAS(signer, 84532);

const result = await compute.within(
  userLocationUID,
  landmarkUID,
  500,  // 500 meters
  { schema: SCHEMA_UID }  // recipient is optional
);

if (result.result) {
  console.log('User is nearby!');
  await eas.submitDelegated(result.delegatedAttestation);
}
```

---

## intersects()

Check if two geometries overlap.

```typescript
compute.intersects(
  geom1: Input,
  geom2: Input,
  options: ComputeOptions
): Promise<BooleanComputeResult>
```

### Example

```typescript
const result = await compute.intersects(
  territory1UID,
  territory2UID,
  { schema: SCHEMA_UID }
);
```

---

## area()

Calculate area of a polygon.

```typescript
compute.area(
  geometry: Input,
  options: ComputeOptions
): Promise<NumericComputeResult>
```

### Example

```typescript
const result = await compute.area(
  propertyBoundaryUID,
  { schema: SCHEMA_UID }
);

console.log(result.result);  // 5432.10 (square meters)
console.log(result.units);   // "square_meters"
```

---

## length()

Calculate length of a line.

```typescript
compute.length(
  geometry: Input,
  options: ComputeOptions
): Promise<NumericComputeResult>
```

### Example

```typescript
const result = await compute.length(
  routeUID,
  { schema: SCHEMA_UID }
);

console.log(result.result);  // 2345.67 (meters)
```

---

## Return Types

### BooleanComputeResult

```typescript
interface BooleanComputeResult {
  result: boolean;
  operation: string;
  timestamp: number;
  inputRefs: string[];
  attestation: {
    uid: string;
    schema: string;
    recipient: string;
    attester: string;
    time: number;
    data: string;
  };
  delegatedAttestation: {
    schema: string;
    data: { ... };
    signature: { v: number; r: string; s: string };
    attester: string;
    deadline: number;
  };
}
```

### NumericComputeResult

```typescript
interface NumericComputeResult {
  result: number;
  units: string;        // "meters" or "square_meters"
  operation: string;
  timestamp: number;
  inputRefs: string[];
  attestation: {
    uid: string;
    schema: string;
    recipient: string;
    attester: string;
    time: number;
    data: string;
  };
  delegatedAttestation: {
    schema: string;
    data: { ... };
    signature: { v: number; r: string; s: string };
    attester: string;
    deadline: number;
  };
}
```

---

## Using Raw GeoJSON

You can mix UIDs and raw GeoJSON:

```typescript
// Check if user is inside a custom polygon
const result = await compute.contains(
  {
    type: 'Polygon',
    coordinates: [[[
      [-122.4194, 37.7749],
      [-122.4094, 37.7749],
      [-122.4094, 37.7849],
      [-122.4194, 37.7849],
      [-122.4194, 37.7749]
    ]]]
  },
  userLocationUID,
  { schema: SCHEMA_UID }
);
```

<Note>
  Raw GeoJSON is not verified for authenticity. The `inputRefs` will contain a keccak256 hash of the geometry.
</Note>

<Card title="Next: Location Methods" icon="location-dot" href="/sdk/location">
  Learn about location attestation methods
</Card>

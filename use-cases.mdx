---
title: "Use Cases"
description: "What you can build with location-based smart contracts"
---

<Warning>
  **Development Preview** — These examples demonstrate the intended patterns.
</Warning>

# What You Can Build

Astral Location Services enables a new category of decentralized applications: **location-based smart contracts**. By combining geospatial computation with EAS resolvers, you can gate any onchain action by real-world location.

## The Pattern

<Steps>
  <Step title="User proves location">
    Creates a location attestation (or submits raw coordinates)
  </Step>
  <Step title="Astral computes">
    Performs spatial operation (distance, containment, etc.) in TEE
  </Step>
  <Step title="Signed result">
    Returns Policy Attestation with computation result
  </Step>
  <Step title="Contract executes">
    Resolver verifies and triggers business logic
  </Step>
</Steps>

---

## Local Currencies

**Concept:** Token pairs that can only be traded by people physically in a region.

Create neighborhood economies where you must be present to participate. SF residents trade BAY tokens, NYC residents trade APPLE tokens.

```typescript
// User in San Francisco
const myLocation = await astral.location.create(userGPS);
const eligibility = await astral.compute.contains(
  sfBayAreaUID,
  myLocation.uid,
  { schema: GEOGATED_SWAP_SCHEMA, submitOnchain: true }
);
// Resolver verifies location → executes swap atomically
```

**Ideas:**
- Neighborhood currencies
- Regional stablecoins
- Tourism tokens (only tradeable in the city)
- Event-specific tokens (festival currency)

---

## Neighborhood DAOs

**Concept:** Governance tokens only mintable by residents of a specific area.

```typescript
const noeValleyDAO = new GeogatedDAO({
  region: noeValleyPolygonUID,
  tokenName: "Noe Valley Governance"
});

// Prove you live/work in the neighborhood
const proof = await astral.compute.contains(
  noeValleyPolygonUID,
  myLocationUID,
  { schema: DAO_MEMBERSHIP_SCHEMA }
);
await noeValleyDAO.join(proof);

// Vote on local issues
await noeValleyDAO.vote(proposalId, voteChoice);
```

**Ideas:**
- Community governance
- Co-op management
- Neighborhood resource allocation
- Local mutual aid networks

---

## Proof-of-Visit NFTs

**Concept:** Collectibles you can only mint by physically visiting a location.

```typescript
// Prove you're at the Eiffel Tower
const proof = await astral.compute.within(
  myLocationUID,
  eiffelTowerUID,
  100,  // within 100 meters
  { schema: VISIT_NFT_SCHEMA, submitOnchain: true }
);

// Resolver mints NFT if you're close enough
```

**Ideas:**
- Travel badges (collect cities/landmarks)
- Conference attendance proofs
- Scavenger hunts with onchain checkpoints
- Historical site verification

---

## Delivery Verification

**Concept:** Escrow that releases only when package arrives at the right location.

```solidity
contract DeliveryEscrow {
    bytes32 public deliveryZoneUID;

    function confirmDelivery(
        bytes32 policyAttestationUID
    ) public {
        Attestation memory att = eas.getAttestation(policyAttestationUID);

        // Verify attester
        require(att.attester == astralSigner, "Not from Astral");

        // Check: was delivery location inside the delivery zone?
        (bool wasInZone, , , ) = abi.decode(
            att.data,
            (bool, bytes32[], uint64, string)
        );

        require(wasInZone, "Wrong delivery location");
        escrow.release();
    }
}
```

**Ideas:**
- P2P delivery marketplaces
- Supply chain verification
- Last-mile logistics
- Food delivery with location proof

---

## Event Check-Ins

**Concept:** POAPs, rewards, or access that require physical presence.

```typescript
// At a conference
const proof = await astral.compute.contains(
  conferenceVenueUID,
  myLocationUID,
  { schema: EVENT_SCHEMA, submitOnchain: true }
);

// Resolver grants access/mints POAP
```

**Ideas:**
- Conference attendance tracking
- Concert/festival badges
- Meetup verification
- Sports event proof-of-attendance

---

## Proximity-Weighted Voting

**Concept:** Vote weight increases the closer you are to what's being voted on.

```solidity
function vote(uint proposalId, bytes32 policyAttestationUID) public {
    // Decode distance from numeric policy attestation
    (uint256 distanceCm, , , , ) = abi.decode(...);
    uint256 distanceM = distanceCm / 100;

    // Closer = more voting power
    uint256 weight = 1000 / (distanceM + 1);
    proposals[proposalId].voteWithWeight(msg.sender, weight);
}
```

**Ideas:**
- Local infrastructure decisions
- Park/facility usage votes
- Noise ordinance voting
- Development impact assessment

---

## Location-Based Marketplaces

**Concept:** Buy/sell only from people in your area.

```typescript
// List item (seller must be in region)
const sellerProof = await astral.compute.contains(
  regionUID,
  sellerLocationUID,
  { schema: MARKETPLACE_SCHEMA }
);
await marketplace.list(itemId, price, sellerProof);

// Buy item (buyer must be nearby seller)
const proximityProof = await astral.compute.within(
  buyerLocationUID,
  sellerLocationUID,
  5000,  // within 5km
  { schema: MARKETPLACE_SCHEMA }
);
await marketplace.buy(itemId, proximityProof);
```

**Ideas:**
- Hyperlocal classifieds
- Farmers markets with verified vendors
- Tool/equipment sharing
- Local services marketplace

---

## Location-Based Games

**Concept:** Onchain gameplay tied to real-world movement.

```typescript
// Capture territory
const proof = await astral.compute.contains(
  territoryUID,
  myLocationUID,
  { schema: GAME_SCHEMA }
);
await game.capture(territoryId, proof);

// Battle (only if players are nearby)
const proximityProof = await astral.compute.distance(
  player1LocationUID,
  player2LocationUID,
  { schema: GAME_SCHEMA }
);
if (proximityProof.result < 100) {
  await game.battle(opponent, proximityProof);
}
```

**Ideas:**
- Territory control games
- AR treasure hunts
- Geocaching with tokens
- Location-based battles

---

## Environmental Monitoring

**Concept:** Carbon credits and conservation proofs tied to physical locations.

```typescript
// Verify tree planting at specified location
const proof = await astral.compute.contains(
  conservationZoneUID,
  plantingSiteUID,
  { schema: CARBON_SCHEMA }
);

await carbonRegistry.registerPlanting(proof, treeCount);
// Mint carbon credits
```

**Ideas:**
- Reforestation verification
- Wildlife habitat monitoring
- Pollution reporting
- Community garden tracking

---

## The Building Blocks

All of these are built with just a few core operations:

| Operation | Use Case Examples |
|-----------|-------------------|
| `distance(a, b)` | Proximity voting, delivery verification |
| `contains(area, point)` | Geofencing, DAO membership, territorial games |
| `within(point, target, radius)` | Proof-of-visit, event check-ins |
| `intersects(a, b)` | Overlapping territories, coverage verification |

Combined with EAS resolvers, these primitives unlock an entirely new design space for Ethereum applications.

<Card title="Get Started" icon="rocket" href="/quickstart">
  Build your first location-based dApp
</Card>

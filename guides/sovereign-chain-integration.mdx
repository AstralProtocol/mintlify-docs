---
title: "Sovereign Chain Integration"
description: "Integrating location proofs with sovereign blockchains and app-chains"
---

<Warning>
  **Research Preview** — Sovereign chain integration patterns are evolving. This guide covers architectural approaches.
</Warning>

# Sovereign Chain Integration

Sovereign blockchains — independent chains with their own consensus, validators, and governance — have unique requirements for location proofs. This guide covers patterns for integrating Astral Location Services with sovereign chains, L2s, and app-chains.

## Why Sovereign Chains Need Location Proofs

### Validator Geographic Distribution

Sovereign chains often require validators to be geographically distributed for:
- **Decentralization**: Preventing regional concentration
- **Regulatory compliance**: Operating validators in specific jurisdictions
- **Latency optimization**: Ensuring global coverage
- **Resilience**: Surviving regional outages

### Sequencer Location Verification

Rollups and app-chains with centralized sequencers may need to prove:
- The sequencer operates in a specific jurisdiction
- Backup sequencers are geographically distributed
- Sequencer location meets SLA requirements

### Jurisdictional Chain Operations

Some sovereign chains are designed for specific jurisdictions:
- EU-compliant chains requiring all infrastructure in EU
- National chains requiring domestic operation
- Regional chains tied to geographic boundaries

---

## Integration Architectures

### Pattern 1: Bridge-Based Integration

For sovereign chains that don't share Ethereum's EAS infrastructure, bridge location attestations from Ethereum:

```
┌─────────────────┐         ┌─────────────────┐
│   Ethereum      │         │  Sovereign      │
│   (Base)        │         │  Chain          │
├─────────────────┤         ├─────────────────┤
│                 │         │                 │
│  Astral TEE     │         │  Location       │
│  Location       │ Bridge  │  Verifier       │
│  Attestations   │────────►│  Contract       │
│  (EAS)          │         │                 │
│                 │         │                 │
└─────────────────┘         └─────────────────┘
```

```typescript
// On Ethereum/Base: Create attestation
const attestation = await astral.compute.contains(
  requiredRegionUID,
  validatorLocationUID,
  { schema: VALIDATOR_COMPLIANCE_SCHEMA }
);

// Bridge the attestation to sovereign chain
await bridge.sendAttestation({
  targetChain: sovereignChainId,
  attestationUID: attestation.uid,
  attestationData: attestation.data
});
```

```solidity
// On sovereign chain: Verify bridged attestation
contract BridgedLocationVerifier {
    address public bridge;
    bytes32 public astralSchemaUID;

    struct LocationProof {
        bool verified;
        bytes32 regionUID;
        uint64 timestamp;
    }

    mapping(address => LocationProof) public validatorLocations;

    function receiveAttestation(
        bytes calldata attestationData,
        bytes calldata bridgeProof
    ) external {
        // Verify bridge proof
        require(bridge.verifyProof(bridgeProof), "Invalid bridge proof");

        // Decode attestation
        (
            bool isInRegion,
            bytes32[] memory inputRefs,
            uint64 timestamp,
            string memory operation
        ) = abi.decode(attestationData, (bool, bytes32[], uint64, string));

        // Store verified location
        validatorLocations[msg.sender] = LocationProof({
            verified: isInRegion,
            regionUID: inputRefs[0],
            timestamp: timestamp
        });
    }
}
```

### Pattern 2: Native Integration

For EVM-compatible sovereign chains, deploy Astral directly:

```
┌─────────────────────────────────────────┐
│          Sovereign Chain (EVM)          │
├─────────────────────────────────────────┤
│                                         │
│  ┌─────────────┐    ┌─────────────────┐ │
│  │ EAS         │    │ Astral Location │ │
│  │ Contracts   │◄───│ Services        │ │
│  └─────────────┘    │ (TEE Signer)    │ │
│         │           └─────────────────┘ │
│         ▼                               │
│  ┌─────────────┐                        │
│  │ Validator   │                        │
│  │ Registry    │                        │
│  └─────────────┘                        │
│                                         │
└─────────────────────────────────────────┘
```

```typescript
// Configure SDK for sovereign chain
const astral = new AstralSDK({
  chainId: sovereignChainId,
  signer: validatorWallet,
  // Custom endpoints for sovereign chain deployment
  endpoints: {
    compute: 'https://compute.sovereign-chain.example',
    eas: sovereignEASAddress
  }
});

// Create location attestation on sovereign chain
const locationProof = await astral.location.create({
  type: 'Point',
  coordinates: validatorLocation
}, {
  submitOnchain: true
});

// Verify validator is in required region
const compliance = await astral.compute.contains(
  requiredRegionUID,
  locationProof.uid,
  {
    schema: VALIDATOR_SCHEMA,
    recipient: validatorAddress
  }
);
```

### Pattern 3: Oracle-Based Integration

For non-EVM chains, use an oracle pattern:

```
┌─────────────────┐         ┌─────────────────┐
│   Astral        │         │  Sovereign      │
│   Location      │         │  Chain          │
│   Services      │         │  (non-EVM)      │
├─────────────────┤         ├─────────────────┤
│                 │         │                 │
│  TEE Compute    │  Oracle │  Location       │
│  + Signing      │────────►│  Module         │
│                 │         │                 │
└─────────────────┘         └─────────────────┘
```

```rust
// Example: Sovereign chain location module (Cosmos SDK style)
pub struct LocationAttestation {
    pub subject: Address,
    pub region_id: String,
    pub is_compliant: bool,
    pub timestamp: u64,
    pub astral_signature: Vec<u8>,
}

impl LocationModule {
    pub fn submit_attestation(
        ctx: Context,
        attestation: LocationAttestation,
    ) -> Result<()> {
        // Verify Astral signature
        let astral_pubkey = self.get_astral_pubkey();
        verify_signature(
            &attestation.astral_signature,
            &attestation.to_bytes(),
            &astral_pubkey
        )?;

        // Store verified attestation
        self.attestations.insert(
            attestation.subject,
            attestation
        );

        Ok(())
    }
}
```

---

## Validator Distribution Verification

A common use case: ensuring validators are geographically distributed.

### Defining Distribution Requirements

```typescript
interface DistributionRequirement {
  regions: {
    id: string;
    name: string;
    polygonUID: string;
    minValidators: number;
    maxValidators: number;
  }[];
  totalMinRegions: number;  // Must have validators in at least N regions
}

const europeDistribution: DistributionRequirement = {
  regions: [
    { id: 'eu-west', name: 'Western Europe', polygonUID: '0x...', minValidators: 2, maxValidators: 10 },
    { id: 'eu-east', name: 'Eastern Europe', polygonUID: '0x...', minValidators: 1, maxValidators: 5 },
    { id: 'eu-north', name: 'Northern Europe', polygonUID: '0x...', minValidators: 1, maxValidators: 5 },
  ],
  totalMinRegions: 2
};
```

### Validator Registration with Location Proof

```typescript
class ValidatorRegistry {
  async registerValidator(
    validatorAddress: string,
    locationUID: string,
    astral: AstralSDK
  ): Promise<void> {
    // Check each region
    for (const region of this.requirements.regions) {
      const result = await astral.compute.contains(
        region.polygonUID,
        locationUID,
        { schema: VALIDATOR_REGISTRATION_SCHEMA }
      );

      if (result.result) {
        // Validator is in this region
        await this.addValidatorToRegion(validatorAddress, region.id, result);
        return;
      }
    }

    throw new Error('Validator not in any approved region');
  }

  async verifyDistribution(): Promise<{
    compliant: boolean;
    distribution: Map<string, number>;
  }> {
    const distribution = new Map<string, number>();

    for (const region of this.requirements.regions) {
      const count = await this.getValidatorCountInRegion(region.id);
      distribution.set(region.id, count);
    }

    const regionsWithValidators = Array.from(distribution.values())
      .filter(count => count > 0).length;

    return {
      compliant: regionsWithValidators >= this.requirements.totalMinRegions,
      distribution
    };
  }
}
```

---

## Sequencer Location Proofs

For rollups with centralized sequencers:

```typescript
class SequencerLocationManager {
  private astral: AstralSDK;
  private requiredRegionUID: string;

  async proveSequencerLocation(): Promise<{
    attestationUID: string;
    compliant: boolean;
  }> {
    // Get sequencer's current location
    const location = await this.getSequencerLocation();

    // Create location attestation
    const locationAttestation = await this.astral.location.create({
      type: 'Point',
      coordinates: location.coordinates
    }, {
      submitOnchain: true,
      metadata: {
        role: 'sequencer',
        sequencerId: this.sequencerId
      }
    });

    // Verify compliance
    const compliance = await this.astral.compute.contains(
      this.requiredRegionUID,
      locationAttestation.uid,
      { schema: SEQUENCER_COMPLIANCE_SCHEMA }
    );

    return {
      attestationUID: compliance.attestation.uid,
      compliant: compliance.result
    };
  }

  async publishComplianceProof(): Promise<void> {
    const proof = await this.proveSequencerLocation();

    // Publish to L1 for transparency
    await this.l1Contract.updateSequencerCompliance(
      proof.attestationUID,
      proof.compliant
    );
  }
}
```

---

## Cross-Chain Location Attestations

When location proofs need to be valid across multiple chains:

```typescript
interface CrossChainAttestation {
  sourceChain: number;
  attestationUID: string;
  targetChains: number[];
}

class CrossChainLocationService {
  async createCrossChainAttestation(
    location: GeoJSON.Point,
    targetChains: number[]
  ): Promise<CrossChainAttestation[]> {
    // Create primary attestation on source chain
    const primaryAttestation = await this.astral.location.create(location, {
      submitOnchain: true
    });

    // Bridge to each target chain
    const crossChainAttestations = await Promise.all(
      targetChains.map(async (chainId) => {
        const bridged = await this.bridgeAttestation(
          primaryAttestation.uid,
          chainId
        );
        return {
          sourceChain: this.astral.chainId,
          attestationUID: primaryAttestation.uid,
          targetChains: [chainId],
          bridgedUID: bridged.uid
        };
      })
    );

    return crossChainAttestations;
  }
}
```

---

## Security Considerations

### Validator Collusion

Multiple validators might collude to falsely attest locations:

```typescript
// Mitigation: Require attestations from multiple independent sources
interface MultiSourceAttestation {
  validatorAttestation: string;
  operatorAttestation: string;
  thirdPartyAudit?: string;
}
```

### Bridge Security

Bridged attestations inherit bridge security assumptions:

```solidity
// Verify bridge isn't compromised
require(bridge.lastUpdateTime() > block.timestamp - 1 hours, "Bridge stale");
require(!bridge.isPaused(), "Bridge paused");
```

### Attestation Freshness

Location can change — ensure attestations are recent:

```solidity
require(
    block.timestamp - attestation.timestamp < MAX_AGE,
    "Attestation too old"
);
```

---

## Implementation Checklist

<Steps>
  <Step title="Choose integration pattern">
    Select bridge-based, native, or oracle pattern based on your chain's architecture
  </Step>
  <Step title="Define location requirements">
    Specify required regions, distribution rules, and compliance criteria
  </Step>
  <Step title="Deploy verification contracts">
    Implement location verification logic on your sovereign chain
  </Step>
  <Step title="Integrate with validator/sequencer registration">
    Require location proofs as part of operator onboarding
  </Step>
  <Step title="Set up monitoring">
    Track location compliance and alert on violations
  </Step>
</Steps>

<Card title="Next: City Chains" icon="city" href="/use-cases/city-chains">
  Explore location proofs for municipal blockchain infrastructure
</Card>
